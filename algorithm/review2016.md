{% include head.html %}

# アルゴリズムとデータ構造2016

## (3) 二分探索木へのノードの挿入・削除
日本語で説明する場合も、ステップごとに分けた方が読みやすい。

### 挿入
二分探索木 $T$ に要素 $p$ を挿入する手順は以下の通り。
1. $T$ の根の要素を $c$ とする。
1. $p<c$ であれば、c の左側の木 $T_1$ に p を挿入する。$c<p$ であれば、右側の木 $T_2$ に p を挿入する。  
なお、$p=c$ であれば、要素 p が既に二分探索木に含まれているので、操作を終了する。
1. 選択した $T_i$ が末端の葉 $l$ である場合、$p,l$ の大小関係に応じて、$p$ を $l$ の左または右の子として挿入する。
1. 選択した $T_i$ が葉でない[^1]場合、$T_i$ に対し、今回定義している $p$ の挿入を再帰的に行う。

[^1]: 2段以上の木である

### 削除
二分探索木 $T$ から要素 $p$ を削除する手順は以下の通り。
1. まず、通常の二分探索を行い、$p$ の位置まで移動する[^2]。
1. $p$ が $T$ の葉である場合、$p$ を削除する。
1. $p$ が葉でなく、左側に $p$ より小さい要素の木 $T_1$ を持つ場合、$T_1$ の最大の要素を削除し、$p$ の位置に移動させる。  
また、このような $T_1$ を持たないとき、$p$ は自身より大きい要素のみからなる木 $T_2$ を右側にもつ。この場合は、$T_2$ の最小の要素を削除し、$p$ の位置に移動させる。

[^2]: この際、$p$ が見つからなければ、エラーを出力して操作を終了する。

参考：[ブログ](https://www.momoyama-usagi.com/entry/info-algo-tree)

## (5) 文字列の出現検知方法
### Trie木
今回の問題で登場した文字列の出現検知手法をTrie木という。  
Trie木は、文字列の効率的な検索（re**trie**val）のために使われるデータ構造。現在の位置から始まる文字列が、それ以前にも出現しているかを `True` or `False` で検知する。

### 参考
- [トライ木の解説と実装](https://algo-logic.info/trie-tree/)

## 配点例

{% include foot.html %}